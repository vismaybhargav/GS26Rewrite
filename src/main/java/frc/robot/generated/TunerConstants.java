package frc.robot.generated;

import static edu.wpi.first.units.Units.Amps;
import static edu.wpi.first.units.Units.Inches;
import static edu.wpi.first.units.Units.KilogramSquareMeters;
import static edu.wpi.first.units.Units.MetersPerSecond;
import static edu.wpi.first.units.Units.Rotations;
import static edu.wpi.first.units.Units.Volts;

import com.ctre.phoenix6.CANBus;
import com.ctre.phoenix6.configs.CANcoderConfiguration;
import com.ctre.phoenix6.configs.CurrentLimitsConfigs;
import com.ctre.phoenix6.configs.Pigeon2Configuration;
import com.ctre.phoenix6.configs.Slot0Configs;
import com.ctre.phoenix6.configs.TalonFXConfiguration;
import com.ctre.phoenix6.hardware.CANcoder;
import com.ctre.phoenix6.hardware.TalonFX;
import com.ctre.phoenix6.signals.StaticFeedforwardSignValue;
import com.ctre.phoenix6.swerve.SwerveDrivetrain;
import com.ctre.phoenix6.swerve.SwerveDrivetrainConstants;
import com.ctre.phoenix6.swerve.SwerveModuleConstants;
import com.ctre.phoenix6.swerve.SwerveModuleConstants.ClosedLoopOutputType;
import com.ctre.phoenix6.swerve.SwerveModuleConstants.DriveMotorArrangement;
import com.ctre.phoenix6.swerve.SwerveModuleConstants.SteerFeedbackType;
import com.ctre.phoenix6.swerve.SwerveModuleConstants.SteerMotorArrangement;
import com.ctre.phoenix6.swerve.SwerveModuleConstantsFactory;

import edu.wpi.first.math.Matrix;
import edu.wpi.first.math.numbers.N1;
import edu.wpi.first.math.numbers.N3;
import edu.wpi.first.units.measure.Angle;
import edu.wpi.first.units.measure.Current;
import edu.wpi.first.units.measure.Distance;
import edu.wpi.first.units.measure.LinearVelocity;
import edu.wpi.first.units.measure.MomentOfInertia;
import edu.wpi.first.units.measure.Voltage;

// Generated by the 2026 Tuner X Swerve Project Generator
// https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/index.html
public class TunerConstants {
	// Both sets of gains need to be tuned to your individual robot.

	// The steer motor uses any SwerveModule.SteerRequestType control request with the
	// output type specified by SwerveModuleConstants.SteerMotorClosedLoopOutput
	private static final double STEER_KP = 100;
	private static final double STEER_KI = 0;
	private static final double STEER_KD = 0.5;
	private static final double STEER_KS = 0.1;
	private static final double STEER_KV = 2.33;
	private static final double STEER_KA = 0;
	private static final Slot0Configs STEER_GAINS = new Slot0Configs()
		.withKP(STEER_KP).withKI(STEER_KI).withKD(STEER_KD)
		.withKS(STEER_KS).withKV(STEER_KV).withKA(STEER_KA)
		.withStaticFeedforwardSign(StaticFeedforwardSignValue.UseClosedLoopSign);
	// When using closed-loop control, the drive motor uses the control
	// output type specified by SwerveModuleConstants.DriveMotorClosedLoopOutput
	private static final double DRIVE_KP = 0.1;
	private static final double DRIVE_KI = 0;
	private static final double DRIVE_KD = 0;
	private static final double DRIVE_KS = 0;
	private static final double DRIVE_KV = 0.124;
	private static final Slot0Configs DRIVE_GAINS = new Slot0Configs()
		.withKP(DRIVE_KP).withKI(DRIVE_KI).withKD(DRIVE_KD)
		.withKS(DRIVE_KS).withKV(DRIVE_KV);

	// The closed-loop output type to use for the steer motors;
	// This affects the PID/FF gains for the steer motors
	private static final ClosedLoopOutputType STEER_CLOSED_LOOP_OUTPUT =
		ClosedLoopOutputType.Voltage;
	// The closed-loop output type to use for the drive motors;
	// This affects the PID/FF gains for the drive motors
	private static final ClosedLoopOutputType DRIVE_CLOSED_LOOP_OUTPUT =
		ClosedLoopOutputType.Voltage;

	// The type of motor used for the drive motor
	private static final DriveMotorArrangement DRIVE_MOTOR_TYPE =
		DriveMotorArrangement.TalonFX_Integrated;
	// The type of motor used for the drive motor
	private static final SteerMotorArrangement STEER_MOTOR_TYPE =
		SteerMotorArrangement.TalonFX_Integrated;

	// The remote sensor feedback type to use for the steer motors;
	// When not Pro-licensed, Fused*/Sync* automatically fall back to Remote*
	private static final SteerFeedbackType STEER_FEEDBACK_TYPE =
		SteerFeedbackType.FusedCANcoder;

	// The stator current at which the wheels start to slip;
	// This needs to be tuned to your individual robot
	private static final Current SLIP_CURRENT = Amps.of(120);

	// Initial configs for the drive and steer motors and the azimuth encoder; these cannot be null.
	// Some configs will be overwritten; check the `with*InitialConfigs()` API documentation.
	private static final TalonFXConfiguration DRIVE_INITIAL_CONFIGS = new TalonFXConfiguration();

	private static final int STEER_STATOR_CURRENT_LIMIT = 60;
	private static final TalonFXConfiguration STEER_INITIAL_CONFIGS = new TalonFXConfiguration()
		.withCurrentLimits(
			new CurrentLimitsConfigs()
				// Swerve azimuth does not require much torque output, so we can set a relatively
				// low stator current limit to help avoid brownouts without impacting performance.
				.withStatorCurrentLimit(Amps.of(STEER_STATOR_CURRENT_LIMIT))
				.withStatorCurrentLimitEnable(true)
		);
	private static final CANcoderConfiguration ENCODER_INITIAL_CONFIGS =
		new CANcoderConfiguration();
	// Configs for the Pigeon 2; leave this null to skip applying Pigeon 2 configs
	private static final Pigeon2Configuration PIGEON_CONFIGS = null;

	// CAN bus that the devices are located on;
	// All swerve devices must share the same CAN bus
	public static final CANBus CAN_BUS = new CANBus("Drivetrain", "./logs/example.hoot");

	// Theoretical free speed (m/s) at 12 V applied output;
	// This needs to be tuned to your individual robot
	public static final LinearVelocity SPEED_12V = MetersPerSecond.of(5.23);

	// Every 1 rotation of the azimuth results in kCoupleRatio drive motor turns;
	// This may need to be tuned to your individual robot
	private static final double COUPLE_RATIO = 3.125;

	private static final double DRIVE_GEAR_RATIO = 5.902777777777778;
	private static final double STEER_GEAR_RATIO = 18.75;
	private static final Distance WHEEL_RADIUS = Inches.of(2);

	private static final boolean INVERT_LEFT_SIDE = false;
	private static final boolean INVERT_RIGHT_SIDE = true;

	private static final int PIGEON_ID = 1;

	// These are only used for simulation
	private static final MomentOfInertia STEER_INERTIA = KilogramSquareMeters.of(0.01);
	private static final MomentOfInertia DRIVE_INERTIA = KilogramSquareMeters.of(0.01);
	// Simulated voltage necessary to overcome friction
	private static final Voltage STEER_FRICTION_VOLTAGE = Volts.of(0.2);
	private static final Voltage DRIVE_FRICTION_VOLTAGE = Volts.of(0.2);

	public static final SwerveDrivetrainConstants DRIVETRAIN_CONSTANTS =
		new SwerveDrivetrainConstants()
				.withCANBusName(CAN_BUS.getName())
				.withPigeon2Id(PIGEON_ID)
				.withPigeon2Configs(PIGEON_CONFIGS);

	private static final SwerveModuleConstantsFactory<
			TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration
		> CONSTANT_CREATOR =
			new SwerveModuleConstantsFactory<
				TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration
			>()
			.withDriveMotorGearRatio(DRIVE_GEAR_RATIO)
			.withSteerMotorGearRatio(STEER_GEAR_RATIO)
			.withCouplingGearRatio(COUPLE_RATIO)
			.withWheelRadius(WHEEL_RADIUS)
			.withSteerMotorGains(STEER_GAINS)
			.withDriveMotorGains(DRIVE_GAINS)
			.withSteerMotorClosedLoopOutput(STEER_CLOSED_LOOP_OUTPUT)
			.withDriveMotorClosedLoopOutput(DRIVE_CLOSED_LOOP_OUTPUT)
			.withSlipCurrent(SLIP_CURRENT)
			.withSpeedAt12Volts(SPEED_12V)
			.withDriveMotorType(DRIVE_MOTOR_TYPE)
			.withSteerMotorType(STEER_MOTOR_TYPE)
			.withFeedbackSource(STEER_FEEDBACK_TYPE)
			.withDriveMotorInitialConfigs(DRIVE_INITIAL_CONFIGS)
			.withSteerMotorInitialConfigs(STEER_INITIAL_CONFIGS)
			.withEncoderInitialConfigs(ENCODER_INITIAL_CONFIGS)
			.withSteerInertia(STEER_INERTIA)
			.withDriveInertia(DRIVE_INERTIA)
			.withSteerFrictionVoltage(STEER_FRICTION_VOLTAGE)
			.withDriveFrictionVoltage(DRIVE_FRICTION_VOLTAGE);


	// Front Left
	private static final int FRONT_LEFT_DRIVE_MOTOR_ID = 10;
	private static final int FRONT_LEFT_STEER_MOTOR_ID = 9;
	private static final int FRONT_LEFT_ENCODER_ID = 5;
	private static final Angle FRONT_LEFT_ENCODER_OFFSET = Rotations.of(0.11083984375);
	private static final boolean FRONT_LEFT_STEER_MOTOR_INVERTED = true;
	private static final boolean FRONT_LEFT_ENCODER_INVERTED = false;

	private static final Distance FRONT_LEFT_X_POS = Inches.of(11.25);
	private static final Distance FRONT_LEFT_Y_POS = Inches.of(11.25);

	// Front Right
	private static final int FRONT_RIGHT_DRIVE_MOTOR_ID = 7;
	private static final int FRONT_RIGHT_STEER_MOTOR_ID = 12;
	private static final int FRONT_RIGHT_ENCODER_ID = 3;
	private static final Angle FRONT_RIGHT_ENCODER_OFFSET = Rotations.of(0.198486328125);
	private static final boolean FRONT_RIGHT_STEER_MOTOR_INVERTED = true;
	private static final boolean FRONT_RIGHT_ENCODER_INVERTED = false;

	private static final Distance FRONT_RIGHT_X_POS = Inches.of(11.25);
	private static final Distance FRONT_RIGHT_Y_POS = Inches.of(-11.25);

	// Back Left
	private static final int BACK_LEFT_DRIVE_MOTOR_ID = 8;
	private static final int BACK_LEFT_STEER_MOTOR_ID = 11;
	private static final int BACK_LEFT_ENCODER_ID = 2;
	private static final Angle BACK_LEFT_ENCODER_OFFSET = Rotations.of(-0.329833984375);
	private static final boolean BACK_LEFT_STEER_MOTOR_INVERTED = true;
	private static final boolean BACK_LEFT_ENCODER_INVERTED = false;

	private static final Distance BACK_LEFT_X_POS = Inches.of(-11.25);
	private static final Distance BACK_LEFT_Y_POS = Inches.of(11.25);

	// Back Right
	private static final int BACK_RIGHT_DRIVE_MOTOR_ID = 6;
	private static final int BACK_RIGHT_STEER_MOTOR_ID = 13;
	private static final int BACK_RIGHT_ENCODER_ID = 4;
	private static final Angle BAC_RIGHT_ENCODER_OFFSET = Rotations.of(0.35498046875);
	private static final boolean BACK_RIGHT_STEER_MOTOR_INVERTED = true;
	private static final boolean BACK_RIGHT_ENCODER_INVERTED = false;

	private static final Distance BACK_RIGHT_X_POS = Inches.of(-11.25);
	private static final Distance BACK_RIGHT_Y_POS = Inches.of(-11.25);


	public static final SwerveModuleConstants<
			TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration
		> FRONT_LEFT =
			CONSTANT_CREATOR.createModuleConstants(
				FRONT_LEFT_STEER_MOTOR_ID, FRONT_LEFT_DRIVE_MOTOR_ID, FRONT_LEFT_ENCODER_ID,
				FRONT_LEFT_ENCODER_OFFSET, FRONT_LEFT_X_POS, FRONT_LEFT_Y_POS, INVERT_LEFT_SIDE,
				FRONT_LEFT_STEER_MOTOR_INVERTED, FRONT_LEFT_ENCODER_INVERTED
			);
	public static final SwerveModuleConstants<
			TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration
		> FRONT_RIGHT =
			CONSTANT_CREATOR.createModuleConstants(
				FRONT_RIGHT_STEER_MOTOR_ID, FRONT_RIGHT_DRIVE_MOTOR_ID, FRONT_RIGHT_ENCODER_ID,
				FRONT_RIGHT_ENCODER_OFFSET, FRONT_RIGHT_X_POS, FRONT_RIGHT_Y_POS, INVERT_RIGHT_SIDE,
				FRONT_RIGHT_STEER_MOTOR_INVERTED, FRONT_RIGHT_ENCODER_INVERTED
			);
	public static final SwerveModuleConstants<
			TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration
		> BACK_LEFT =
			CONSTANT_CREATOR.createModuleConstants(
				BACK_LEFT_STEER_MOTOR_ID, BACK_LEFT_DRIVE_MOTOR_ID, BACK_LEFT_ENCODER_ID,
				BACK_LEFT_ENCODER_OFFSET, BACK_LEFT_X_POS, BACK_LEFT_Y_POS, INVERT_LEFT_SIDE,
				BACK_LEFT_STEER_MOTOR_INVERTED, BACK_LEFT_ENCODER_INVERTED
			);
	public static final SwerveModuleConstants<
			TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration
		> BACK_RIGHT =
			CONSTANT_CREATOR.createModuleConstants(
				BACK_RIGHT_STEER_MOTOR_ID, BACK_RIGHT_DRIVE_MOTOR_ID, BACK_RIGHT_ENCODER_ID,
				BAC_RIGHT_ENCODER_OFFSET, BACK_RIGHT_X_POS, BACK_RIGHT_Y_POS, INVERT_RIGHT_SIDE,
				BACK_RIGHT_STEER_MOTOR_INVERTED, BACK_RIGHT_ENCODER_INVERTED
			);

	/**
	 * Creates a CommandSwerveDrivetrain instance.
	 * This should only be called once in your robot program,.
	 *
	 * @return the drivetrain
	 */
	public static CommandSwerveDrivetrain createDrivetrain() {
		return new CommandSwerveDrivetrain(
			DRIVETRAIN_CONSTANTS, FRONT_LEFT, FRONT_RIGHT, BACK_LEFT, BACK_RIGHT
		);
	}


	/**
	 * Swerve Drive class utilizing CTR Electronics' Phoenix 6 API with the selected device types.
	 */
	public static class TunerSwerveDrivetrain extends SwerveDrivetrain<TalonFX, TalonFX, CANcoder> {
		/**
		 * Constructs a CTRE SwerveDrivetrain using the specified constants.
		 * <p>
		 * This constructs the underlying hardware devices, so users should not construct
		 * the devices themselves. If they need the devices, they can access them through
		 * getters in the classes.
		 *
		 * @param drivetrainConstants   Drivetrain-wide constants for the swerve drive
		 * @param modules			   Constants for each specific module
		 */
		public TunerSwerveDrivetrain(
			SwerveDrivetrainConstants drivetrainConstants,
			SwerveModuleConstants<?, ?, ?>... modules
		) {
			super(
				TalonFX::new, TalonFX::new, CANcoder::new,
				drivetrainConstants, modules
			);
		}

		/**
		 * Constructs a CTRE SwerveDrivetrain using the specified constants.
		 * <p>
		 * This constructs the underlying hardware devices, so users should not construct
		 * the devices themselves. If they need the devices, they can access them through
		 * getters in the classes.
		 *
		 * @param drivetrainConstants	 Drivetrain-wide constants for the swerve drive
		 * @param odometryUpdateFrequency The frequency to run the odometry loop. If
		 *								unspecified or set to 0 Hz, this is 250 Hz on
		 *								CAN FD, and 100 Hz on CAN 2.0.
		 * @param modules				 Constants for each specific module
		 */
		public TunerSwerveDrivetrain(
			SwerveDrivetrainConstants drivetrainConstants,
			double odometryUpdateFrequency,
			SwerveModuleConstants<?, ?, ?>... modules
		) {
			super(
				TalonFX::new, TalonFX::new, CANcoder::new,
				drivetrainConstants, odometryUpdateFrequency, modules
			);
		}

		/**
		 * Constructs a CTRE SwerveDrivetrain using the specified constants.
		 * <p>
		 * This constructs the underlying hardware devices, so users should not construct
		 * the devices themselves. If they need the devices, they can access them through
		 * getters in the classes.
		 *
		 * @param drivetrainConstants	   Drivetrain-wide constants for the swerve drive
		 * @param odometryUpdateFrequency   The frequency to run the odometry loop. If
		 *								  unspecified or set to 0 Hz, this is 250 Hz on
		 *								  CAN FD, and 100 Hz on CAN 2.0.
		 * @param odometryStandardDeviation The standard deviation for odometry calculation
		 *								  in the form [x, y, theta]áµ€, with units in meters
		 *								  and radians
		 * @param visionStandardDeviation   The standard deviation for vision calculation
		 *								  in the form [x, y, theta]áµ€, with units in meters
		 *								  and radians
		 * @param modules				   Constants for each specific module
		 */
		public TunerSwerveDrivetrain(
			SwerveDrivetrainConstants drivetrainConstants,
			double odometryUpdateFrequency,
			Matrix<N3, N1> odometryStandardDeviation,
			Matrix<N3, N1> visionStandardDeviation,
			SwerveModuleConstants<?, ?, ?>... modules
		) {
			super(
				TalonFX::new, TalonFX::new, CANcoder::new,
				drivetrainConstants, odometryUpdateFrequency,
				odometryStandardDeviation, visionStandardDeviation, modules
			);
		}
	}
}
